/**
 * The function tests if a given integer is considered happy, that is, the sum of its squared digits and the sequence generated by consequently summing up the results' squared digits reaches 1. Consequently, a number that generates a cyclical sequence is considered unhappy.
 *
 * @see https://www.youtube.com/watch?v=kC6YObu61_w
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 * @return {boolean} - True, if the number is happy – otherwise false.
 */
exports.isHappy = function (number) {
  validateArgument(number)

	let cycle = []

	while (number != 1) {
		if (cycle.includes(number))
			return false

		cycle.push(number)

		number = sumSquaredDigits(number)
	}

	return true
}

/**
 * The function takes a number and splits its digits into an ordered array.
 *
 * @access private
 * @param {number} - number ∈ Z
 * @return {number[]} - The argument's digits in an array
 */
function splitDigits(number) {
	return number.toString().split('').map(function (digit) { return parseInt(digit) })
}

/**
 * Sums up the squared digits of a number.
 *
 * @access private
 * @param {number} - number ∈ Z
 * @return {number} - The total sum of the argument's squared digits
 */
function sumSquaredDigits(number) {
	let numberDigits = splitDigits(number)
	let summedSquaredDigits = numberDigits.reduce(function (accumulator, number) {
		return accumulator + Math.pow(number, 2)
  }, 0)

	return summedSquaredDigits
}

/**
 * The function tests if a given integer is considered narcissistic, that is, the sum of its digits raised separately to the power equal to the length of the number yield the number itself. For example: 153; 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153.
 *
 * @see https://www.youtube.com/watch?v=4aMtJ-V26Z4
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 * @return {boolean} - True, if the number is narcissistic – otherwise false.
 */
exports.isNarcissistic = function (number) {
  validateArgument(number)

  let numberDigits = splitDigits(number)
  let power = numberDigits.length

  let summedRaisedDigits = numberDigits.reduce(function (accumulator, number) {
    return accumulator + Math.pow(number, power)
  }, 0)

  if (summedRaisedDigits == number)
    return true
  else
    return false
}

/**
 * The function tests if a given integer is considered grafting, that is, the number sequence it represents itself is in contact with the decimal point in its own square root.
 *
 * @see https://www.youtube.com/watch?v=hiOMtBrH8pc
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 * @return {boolean} - True, if the number is grafting – otherwise false.
 */
exports.isGrafting = function (number) {
  validateArgument(number)

  let squareRoot = Math.sqrt(number),
    squareRootString = squareRoot.toString(),
    numberString = number.toString()

  for (let i = 0; i < numberString.length; i++) {
    let numberDigits = numberString.split('')
    numberDigits.splice(i, 0, '.')
    if (squareRootString.includes(numberDigits.join('')))
      return true
  }

  return false
}

/**
 * A guard function to prevent invalid arguments to the Numberphile functions
 *
 * @access private
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 */
function validateArgument(number) {
  if (isNaN(number) || !Number.isInteger(number)) {
    throw new Error('Invalid argument')
  }
}
