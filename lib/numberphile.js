const Utilities = require('./numberphile/utilities'),
	Validators = require('./numberphile/validators')

/**
 * The function tests if a given integer is considered happy, that is, the sum of its squared digits and the sequence generated by consequently summing up the results' squared digits reaches 1. Consequently, a number that generates a cyclical sequence is considered unhappy.
 *
 * @see https://www.youtube.com/watch?v=kC6YObu61_w
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N \ 0
 * @return {boolean} True, if the number is happy – otherwise false.
 */
exports.isHappy = function (number) {
	Validators.validateArgument(number)

	let cycle = []

	while (number != 1) {
		if (cycle.includes(number))
			return false

		cycle.push(number)

		number = Utilities.sumSquaredDigits(number)
	}

	return true
}

/**
 * The function tests if a given integer is considered narcissistic, that is, the sum of its digits raised separately to the power equal to the length of the number yield the number itself. For example: 153; 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153.
 *
 * @see https://www.youtube.com/watch?v=4aMtJ-V26Z4
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N \ 0
 * @return {boolean} True, if the number is narcissistic – otherwise false.
 */
exports.isNarcissistic = function (number) {
	Validators.validateArgument(number)

	let numberDigits = Utilities.splitDigits(number)
	let power = numberDigits.length

	let summedRaisedDigits = numberDigits.reduce(function (accumulator, number) {
		return accumulator + Math.pow(number, power)
	}, 0)

	if (summedRaisedDigits == number)
		return true
	else
		return false
}

/**
 * The function tests if a given integer is considered grafting, that is, the number sequence it represents itself is in contact with the decimal point in its own square root.
 *
 * @see https://www.youtube.com/watch?v=hiOMtBrH8pc
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N \ 0
 * @return {boolean} True, if the number is grafting – otherwise false.
 */
exports.isGrafting = function (number) {
	Validators.validateArgument(number)

	let squareRoot = Math.sqrt(number),
		squareRootString = squareRoot.toString(),
		numberString = number.toString()

	for (let i = 0; i < numberString.length; i++) {
		let numberDigits = numberString.split('')
		numberDigits.splice(i, 0, '.')
		if (squareRootString.includes(numberDigits.join('')))
			return true
	}

	return false
}

/**
 * The function tests if a given integer is considered highly composite, that is, the number has more factors than any other number less than itself.
 *
 * @see https://www.youtube.com/watch?v=2JM2oImb9Qg
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N \ 0
 * @return {boolean} True, if the number is highly composite – otherwise false.
 */
exports.isHighlyComposite = function (number) {
	Validators.validateArgument(number)
	let factorsCount = Utilities.getFactors(number).length

// Start from large to small; might end up halting earlier on larger numbers
	for (let i = number - 1; i > 0; i--) {
		if (factorsCount <= Utilities.getFactors(i).length)
			return false
	}

	return true
}

/**
 * The function tests if a given integer is considered perfect, that is, the number's factors add up to the number itself.
 *
 * @see https://www.youtube.com/watch?v=ZfKTD5lvToE
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N \ 0
 * @return {boolean} True, if the number is perfect, otherwise false. 
 */
exports.isPerfect = function (number) {
	Validators.validateArgument(number)

	// Ignore the number itself by subtracting it from the result
	let factorsSum = Utilities.getFactors(number).reduce(function (accumulator, factor) { return accumulator + factor }) - number

	if (number == factorsSum)
		return true

	return false
}

/**
 * The function tests if two given integers are considered an amicable pair, that is, the sum of the numbers' factors – excluding themselves – are equal to each other.
 *
 * @see https://www.youtube.com/watch?v=fUSZBVYZdKY
 * @access public
 * @param {number} firstNumber - firstNumber ∈ N \ 0
 * @param {number} secondNumber - secondNumber ∈ N \ 0
 * @return {boolean} True, if the number pair is amicable, otherwise false.
 */
exports.areAmicable = function (firstNumber, secondNumber) {
	[firstNumber, secondNumber].forEach(function (number) { Validators.validateArgument(number) })

	// Subtract the number itself
	if (firstNumber != (Utilities.getFactors(secondNumber).reduce(function (accumulator, factor) { return accumulator + factor }) - secondNumber))
		return false

	// Subtract the number itself
	if (secondNumber == (Utilities.getFactors(firstNumber).reduce(function (accumulator, factor) { return accumulator + factor }) - firstNumber))
		return true

	return false
}

/**
 * The function tests if a given integer is a Mersenne prime, that is, it's a prime number that when added 1 yields a power of two.
 *
 * @see https://www.youtube.com/watch?v=PLL0mo5rHhk
 * @access public
 * @param {number} number - number ∈ N
 * @return {boolean} True, if the number is Mersenne prime, otherwise false
 */
exports.isMersennePrime = function (number) {
	Validators.validateArgument(number)

	// Checking the power of two first before primality is essential
	if (Utilities.isPowerOfTwo(number + 1) && Utilities.isPrime(number))
		return true

	return false
}
