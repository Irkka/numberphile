/**
 * The function tests if a given integer is considered happy, that is, the sum of its squared digits and the sequence generated by consequently summing up the results' squared digits reaches 1. Consequently, a number that generates a cyclical sequence is considered unhappy.
 *
 * @see https://www.youtube.com/watch?v=kC6YObu61_w
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 * @return {boolean} True, if the number is happy – otherwise false.
 */
exports.isHappy = function (number) {
	validateArgument(number)

	let cycle = []

	while (number != 1) {
		if (cycle.includes(number))
			return false

		cycle.push(number)

		number = sumSquaredDigits(number)
	}

	return true
}

/**
 * The function takes a number and splits its digits into an ordered array.
 *
 * @access private
 * @param {number} - number ∈ Z
 * @return {number[]} The argument's digits in an array
 */
function splitDigits(number) {
	return number.toString().split('').map(function (digit) { return parseInt(digit) })
}

/**
 * Sums up the squared digits of a number.
 *
 * @access private
 * @param {number} - number ∈ Z
 * @return {number} The total sum of the argument's squared digits
 */
function sumSquaredDigits(number) {
	let numberDigits = splitDigits(number)
	let summedSquaredDigits = numberDigits.reduce(function (accumulator, number) {
		return accumulator + Math.pow(number, 2)
	}, 0)

	return summedSquaredDigits
}

/**
 * The function tests if a given integer is considered narcissistic, that is, the sum of its digits raised separately to the power equal to the length of the number yield the number itself. For example: 153; 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153.
 *
 * @see https://www.youtube.com/watch?v=4aMtJ-V26Z4
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 * @return {boolean} True, if the number is narcissistic – otherwise false.
 */
exports.isNarcissistic = function (number) {
	validateArgument(number)

	let numberDigits = splitDigits(number)
	let power = numberDigits.length

	let summedRaisedDigits = numberDigits.reduce(function (accumulator, number) {
		return accumulator + Math.pow(number, power)
	}, 0)

	if (summedRaisedDigits == number)
		return true
	else
		return false
}

/**
 * The function tests if a given integer is considered grafting, that is, the number sequence it represents itself is in contact with the decimal point in its own square root.
 *
 * @see https://www.youtube.com/watch?v=hiOMtBrH8pc
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 * @return {boolean} True, if the number is grafting – otherwise false.
 */
exports.isGrafting = function (number) {
	validateArgument(number)

	let squareRoot = Math.sqrt(number),
		squareRootString = squareRoot.toString(),
		numberString = number.toString()

	for (let i = 0; i < numberString.length; i++) {
		let numberDigits = numberString.split('')
		numberDigits.splice(i, 0, '.')
		if (squareRootString.includes(numberDigits.join('')))
			return true
	}

	return false
}

/**
 * A guard function to prevent invalid arguments to the Numberphile functions
 *
 * @access private
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ Z
 */
function validateArgument(number) {
	if (isNaN(number) || !Number.isInteger(number)) {
		throw new Error('Invalid argument')
	}
}

/**
 * A guard function to prevent non-positive arguments to the Numberphile functions
 *
 * @access private
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N
 */
function isPositiveInteger(number) {
	validateArgument(number)
	if (number <= 0) {
		throw new Error('Non-positive argument')
	}
}

/**
 * The function tests if a given integer is considered highly composite, that is, the number has more factors than any other number less than itself.
 *
 * @see https://www.youtube.com/watch?v=2JM2oImb9Qg
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N
 * @return {boolean} True, if the number is highly composite – otherwise false.
 */
exports.isHighlyComposite = function (number) {
	isPositiveInteger(number)
	let factorsCount = getFactors(number).length

// Start from large to small; might end up halting earlier on larger numbers
	for (let i = number - 1; i > 0; i--) {
		if (factorsCount <= getFactors(i).length)
			return false
	}

	return true
}

/**
 * The function returns an array of the positive integer argument's factors.
 *
 * @access private
 * @param {number} number - number ∈ N
 * @return {number[]} Array of factors
 */
function getFactors(number) {
	let factors = []

	for (let i = 1; i <= number; i++) {
		if(number % i == 0) {
			factors.push(i)
		}
	}

	return factors
}

/**
 * The function tests if a given integer is considered perfect, that is, the number's factors add up to the number itself.
 *
 * @see https://www.youtube.com/watch?v=ZfKTD5lvToE
 * @access public
 * @throws {Error} An error when called with an invalid argument
 * @param {number} number - number ∈ N
 * @return {boolean} True, if the number is perfect, otherwise false. 
 */
exports.isPerfect = function (number) {
	isPositiveInteger(number)

	// Ignore the number itself by subtracting it from the result
	let factorsSum = getFactors(number).reduce(function (accumulator, factor) { return accumulator + factor }) - number

	if (number == factorsSum)
		return true

	return false
}

/**
 * The function tests if two given integers are considered an amicable pair, that is, the sum of the numbers' factors – excluding themselves – are equal to each other.
 *
 * @see https://www.youtube.com/watch?v=fUSZBVYZdKY
 * @access public
 * @param {number} firstNumber - The first operand
 * @param {number} secondNumber - The second operand
 * @return {boolean} True, if the number pair is amicable, otherwise false.
 */
exports.areAmicable = function (firstNumber, secondNumber) {
	[firstNumber, secondNumber].forEach(function (number) { isPositiveInteger(number) })

	// Subtract the number itself
	if (firstNumber != (getFactors(secondNumber).reduce(function (accumulator, factor) { return accumulator + factor }) - secondNumber))
		return false

	// Subtract the number itself
	if (secondNumber == (getFactors(firstNumber).reduce(function (accumulator, factor) { return accumulator + factor }) - firstNumber))
		return true

	return false
}
